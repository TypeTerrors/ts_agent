import { useEffect, useMemo, useState } from "react";
import dayjs from "dayjs";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "./components/ui/card";

interface WindowShape {
  rows: number;
  cols: number;
}

interface PredictionPayload {
  probability: number;
  exposure: number;
  forecastVolatility: number;
  barsCount: number;
  trainedSamples: number;
  windowShape: WindowShape | null;
  symbol: string;
  createdAt?: string;
}

const formatPercent = (value: number) => `${(value * 100).toFixed(2)}%`;

export const App = () => {
  const [predictions, setPredictions] = useState<PredictionPayload[]>([]);
  const [status, setStatus] = useState<string>("Connecting to websocket…");

  const wsUrl = useMemo(() => {
    const base = import.meta.env.VITE_WS_URL as string | undefined;
    return base ?? "ws://localhost:8080/ws";
  }, []);

  useEffect(() => {
    const socket = new WebSocket(wsUrl);

    socket.onopen = () => {
      setStatus("Connected");
    };

    socket.onmessage = (event) => {
      try {
        const payload: PredictionPayload = JSON.parse(event.data);
        setPredictions((prev) => [
          {
            ...payload,
            createdAt: payload.createdAt ?? new Date().toISOString(),
          },
          ...prev,
        ]);
      } catch (error) {
        console.error("Failed to parse websocket payload", error);
      }
    };

    socket.onclose = () => {
      setStatus("Disconnected");
    };

    socket.onerror = (event) => {
      console.error("Websocket error", event);
      setStatus("Error");
    };

    return () => {
      socket.close();
    };
  }, [wsUrl]);

  return (
    <div className="min-h-screen bg-background text-foreground">
      <div className="mx-auto flex max-w-6xl flex-col gap-8 p-8 md:flex-row">
        <section className="md:w-2/5">
          <h1 className="text-3xl font-bold tracking-tight mb-4">
            TS Trade Prediction Dashboard
          </h1>
          <p className="text-muted-foreground leading-relaxed">
            This dashboard listens for real-time prediction payloads generated by the
            TypeScript training engine. As new forecasts are stored in Postgres, the Go
            websocket API streams them to this UI. Each card summarises the model&rsquo;s
            probability of an up-move, the resulting exposure after the risk map, and
            metadata about the window used for that inference.
          </p>
          <div className="mt-6 rounded-lg border border-border bg-muted/40 p-4 text-sm">
            <p className="font-medium">Connection status: {status}</p>
            <p className="text-muted-foreground">Listening on {wsUrl}</p>
            <p className="text-muted-foreground">
              Newest predictions appear at the top of the feed.
            </p>
          </div>
        </section>

        <section className="md:w-3/5">
          <h2 className="text-2xl font-semibold mb-4">Live predictions</h2>
          <div className="space-y-4">
            {predictions.length === 0 ? (
              <Card>
                <CardHeader>
                  <CardTitle>No predictions yet</CardTitle>
                  <CardDescription>
                    When the trainer emits its next payload it will appear here instantly.
                  </CardDescription>
                </CardHeader>
              </Card>
            ) : (
              predictions.map((prediction, index) => (
                <Card key={`${prediction.symbol}-${prediction.createdAt ?? index}`}>
                  <CardHeader>
                    <CardTitle>{prediction.symbol}</CardTitle>
                    <CardDescription>
                      {prediction.createdAt
                        ? dayjs(prediction.createdAt).format("MMM D, YYYY h:mm:ss A")
                        : "Just now"}
                    </CardDescription>
                  </CardHeader>
                  <CardContent className="grid gap-3 text-sm">
                    <div className="grid grid-cols-2 gap-2">
                      <Metric label="Probability" value={formatPercent(prediction.probability)} />
                      <Metric label="Exposure" value={formatPercent(Math.abs(prediction.exposure))} />
                      <Metric
                        label="Forecast volatility"
                        value={prediction.forecastVolatility.toExponential(2)}
                      />
                      <Metric label="Bars" value={prediction.barsCount.toString()} />
                      <Metric label="Samples" value={prediction.trainedSamples.toString()} />
                      <Metric
                        label="Window"
                        value={prediction.windowShape ? `${prediction.windowShape.rows}×${prediction.windowShape.cols}` : "n/a"}
                      />
                    </div>
                  </CardContent>
                </Card>
              ))
            )}
          </div>
        </section>
      </div>
    </div>
  );
};

interface MetricProps {
  label: string;
  value: string;
}

const Metric = ({ label, value }: MetricProps) => (
  <div className="rounded-lg border border-border bg-card/50 p-3">
    <p className="text-xs uppercase tracking-wide text-muted-foreground">{label}</p>
    <p className="text-sm font-medium text-foreground">{value}</p>
  </div>
);
