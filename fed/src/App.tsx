import { useEffect, useMemo, useState } from "react";
import dayjs from "dayjs";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "./components/ui/card";

interface WindowShape {
  rows: number;
  cols: number;
}

interface PredictionPayload {
  probability: number;
  exposure: number;
  forecastVolatility: number;
  barsCount: number;
  trainedSamples: number;
  windowShape: WindowShape | null;
  symbol: string;
  createdAt?: string;
}

const formatPercent = (value: number) => `${(value * 100).toFixed(2)}%`;

export const App = () => {
  const [predictions, setPredictions] = useState<PredictionPayload[]>([]);
  const [status, setStatus] = useState<string>("Connecting to websocket…");

  const wsUrl = useMemo(() => {
    const base = import.meta.env.VITE_WS_URL as string | undefined;
    return base ?? "ws://localhost:8080/ws";
  }, []);

  const pingMs = useMemo(() => {
    const raw = import.meta.env.VITE_WS_PING_MS as string | undefined;
    const n = raw ? Number(raw) : NaN;
    return Number.isFinite(n) && n > 0 ? n : 25000;
  }, []);

  const apiRecentUrl = useMemo(() => {
    const explicit = import.meta.env.VITE_API_URL as string | undefined;
    if (explicit) {
      return `${explicit.replace(/\/$/, "")}/recent`;
    }
    // Derive from wsUrl: ws://host:port/ws -> http://host:port/recent
    try {
      const u = new URL(wsUrl);
      u.protocol = u.protocol === "wss:" ? "https:" : "http:";
      // Trim a trailing /ws or /ws/
      u.pathname = u.pathname.replace(/\/?ws\/?$/, "");
      u.pathname = (u.pathname.endsWith("/") ? u.pathname.slice(0, -1) : u.pathname) + "/recent";
      u.search = "";
      u.hash = "";
      return u.toString();
    } catch {
      return "http://localhost:8080/recent";
    }
  }, [wsUrl]);

  useEffect(() => {
    // 1) Prime the dashboard with recent predictions
    const ac = new AbortController();
    fetch(apiRecentUrl, { signal: ac.signal })
      .then(async (res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data: PredictionPayload[] = await res.json();
        // Ensure array and newest-first ordering retained
        if (Array.isArray(data)) setPredictions(data);
      })
      .catch((err) => {
        console.error("Failed to fetch recent predictions", err);
      });

    // 2) Connect websocket for live updates
    const socket = new WebSocket(wsUrl);
    let pingTimer: number | undefined;

    socket.onopen = () => {
      setStatus("Connected");
      // Start application-level heartbeat every 25s
      pingTimer = window.setInterval(() => {
        if (socket.readyState === WebSocket.OPEN) {
          const msg = { type: "ping", ts: new Date().toISOString() };
          socket.send(JSON.stringify(msg));
          console.debug("WS ping sent", msg);
        }
      }, pingMs);
    };

    socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data && data.type === "pong") {
          console.debug("WS pong received", data);
          return;
        }
        const payload: PredictionPayload = data;
        setPredictions((prev) => [
          {
            ...payload,
            createdAt: payload.createdAt ?? new Date().toISOString(),
          },
          ...prev,
        ]);
      } catch (error) {
        // Non-JSON payloads are ignored; keep logs for debugging
        console.error("Failed to parse websocket payload", error);
      }
    };

    socket.onclose = () => {
      setStatus("Disconnected");
      if (pingTimer) window.clearInterval(pingTimer);
    };

    socket.onerror = (event) => {
      console.error("Websocket error", event);
      setStatus("Error");
    };

    return () => {
      ac.abort();
      if (pingTimer) window.clearInterval(pingTimer);
      socket.close();
    };
  }, [wsUrl, apiRecentUrl, pingMs]);

  return (
    <div className="min-h-screen bg-background text-foreground">
      <div className="mx-auto flex max-w-6xl flex-col gap-8 p-8 md:flex-row">
        <section className="md:w-2/5">
          <h1 className="text-3xl font-bold tracking-tight mb-4">
            TS Trade Prediction Dashboard
          </h1>
          <p className="text-muted-foreground leading-relaxed">
            This dashboard listens for real-time prediction payloads generated by the
            TypeScript training engine. As new forecasts are stored in Postgres, the Go
            websocket API streams them to this UI. Each card summarises the model&rsquo;s
            probability of an up-move, the resulting exposure after the risk map, and
            metadata about the window used for that inference.
          </p>
          <div className="mt-6 rounded-lg border border-border bg-muted/40 p-4 text-sm">
            <p className="font-medium">Connection status: {status}</p>
            <p className="text-muted-foreground">Listening on {wsUrl}</p>
            <p className="text-muted-foreground">
              Newest predictions appear at the top of the feed.
            </p>
          </div>
        </section>

        <section className="md:w-3/5 flex flex-col">
          <h2 className="text-2xl font-semibold mb-4">Live predictions</h2>
          <div className="max-h-[75vh] overflow-y-auto pr-2 space-y-4">
            {predictions.length === 0 ? (
              <Card>
                <CardHeader>
                  <CardTitle>No predictions yet</CardTitle>
                  <CardDescription>
                    When the trainer emits its next payload it will appear here instantly.
                  </CardDescription>
                </CardHeader>
              </Card>
            ) : (
              predictions.map((prediction, index) => (
                <Card key={`${prediction.symbol}-${prediction.createdAt ?? index}`}>
                  <CardHeader>
                    <CardTitle>{prediction.symbol}</CardTitle>
                    <CardDescription>
                      {prediction.createdAt
                        ? dayjs(prediction.createdAt).format("MMM D, YYYY h:mm:ss A")
                        : "Just now"}
                    </CardDescription>
                  </CardHeader>
                  <CardContent className="grid gap-3 text-sm">
                    <div className="grid grid-cols-2 gap-2">
                      <Metric label="Probability" value={formatPercent(prediction.probability)} />
                      <Metric label="Exposure" value={formatPercent(Math.abs(prediction.exposure))} />
                      <Metric
                        label="Forecast volatility"
                        value={prediction.forecastVolatility.toExponential(2)}
                      />
                      <Metric label="Bars" value={prediction.barsCount.toString()} />
                      <Metric label="Samples" value={prediction.trainedSamples.toString()} />
                      <Metric
                        label="Window"
                        value={prediction.windowShape ? `${prediction.windowShape.rows}×${prediction.windowShape.cols}` : "n/a"}
                      />
                    </div>
                  </CardContent>
                </Card>
              ))
            )}
          </div>
        </section>
      </div>
    </div>
  );
};

interface MetricProps {
  label: string;
  value: string;
}

const Metric = ({ label, value }: MetricProps) => (
  <div className="rounded-lg border border-border bg-card/50 p-3">
    <p className="text-xs uppercase tracking-wide text-muted-foreground">{label}</p>
    <p className="text-sm font-medium text-foreground">{value}</p>
  </div>
);
